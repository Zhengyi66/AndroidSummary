### 一、Binder核心方法

#### 1、binder_init

主要是注册字符(misc)设备：

杂项设备（misc device）：杂项设备也是在嵌入式系统中用得比较多的一种**设备驱动**

#### 2、binder_open

打开binder驱动设备。

创建 binder_proc 对象（binder进程结构体），并把binder_proc 对象加入到全局链表 binder_procs

### 3、binder_mmap

首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存； 

然后再申请 1 个 page 大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的 Buffer 和内核空间的 Buffer 同步操作的功能

#### 4、binder_ioctl

binder_ioctl()函数负责在两个进程间收发 IPC 数据和 IPC reply 数据。

常见ioctl命令有：BINDER_WRITE_READ

#### 总结

- binder_init：初始化字符设备； 

- binder_open：打开驱动设备，过程需要持有 binder_main_lock 同步锁； 

- binder_mmap：申请内存空间，该过程需要持有 binder_mmap_lock 同步 锁； 

- binder_ioctl：执行相应的 ioctl 操作，该过程需要持有 binder_main_lock 同步锁； 

  当处于 binder_thread_read 过程，read_buffer 无数据则释放同步 锁，并处于 wait_event_freezable 过程，等有数据到来则唤醒并尝 试持有同步锁

### 二、ServiceManager 启动流程

1. 打开 binder 驱动，并调用 mmap()方法分配 128k 的内存映射空间： binder_open(); 
2. 通 知 binder 驱 动 使 其 成 为 守 护 进 程 ： binder_become_context_manager()； 
3. 验证 selinux 权限，判断进程是否有权注册或查看指定服务； 
4. 进入循环状态，等待 Client 端的请求：binder_loop()。 
5. 注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先 移除之前的注册信息； 
6. 死亡通知: 当 binder 所在进程死亡后,会调用 binder_release 方法,然后调 用 binder_node_release.这个过程便会发出死亡通知的回调. 

**ServiceManager 最核心的两个功能为查询和注册服务：** 

- 注册服务：记录服务名和 handle 信息，保存到 svclist 列表； 
- 查询服务：根据服务名查询相应的的 handle 信息

### 三、Binder面试题

#### 1、为什么是Binder

从性能、稳定性、安全性来答

#### 2.Binder 是如何做到一次拷贝的 

主要是因为 **Linux 是使用的虚拟内存寻址方式**，它有如下特性： 

- 用户空间的虚拟内存地址是映射到物理内存中的 

- 对虚拟内存的读写实际上是对物理内存的读写，这个过程就是内存映射 

- 这个内存映射过程是通过系统调用 mmap()来实现的 

  Binder 借助了内存映射的方法，在内核空间和接收方用户空间的数据缓存区之间做 了一层内存映射，就相当于直接拷贝到了接收方用户空间的数据缓存区，从而减少 了一次数据拷贝

#### 3、MMAP 的内存映射原理了解

**MMAP 内存映射的实现过程，总的来说可以分为三个阶段：** 

##### 3.1、进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域 

1、进程在用户空间调用库函数 mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); 

2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址 

3、为此虚拟区分配一个 vm_area_struct 结构，接着对这个结构的各个域进行了初始化 

4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中 

##### 3.2、调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件 物理地址和进程虚拟地址的一一映射关系 

1、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找 到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文 件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。 

2、通过该文件的文件结构体，链接到 file_operations 模块，调用内核函数 mmap，其原 型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。 

3、内核 mmap 函数通过虚拟文件系统 inode 模块定位到文件磁盘物理地址。 

4、通过 remap_pfn_range 函数建立页表，即实现了文件地址和虚拟地址区域的映射关 系。此时，这片虚拟地址并没有任何数据关联到主存中

##### 3.3、进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理 内存（主存）的拷贝

 注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数 据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一 段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有 拷贝到内存中，因此引发缺页异常。 

1. 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。 
2. 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则 调用 nopage 函数把所缺的页从磁盘装入到主存中。 
3. 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时 间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调 用 msync()来强制同步, 这样所写的内容就能立即保存到文件里了

#### 4.Binder 机制是如何跨进程的 

1.Binder 驱动 

 - 在内核空间创建一块接收缓存区，  
 - 实现地址映射：将内核缓存区、接收进程用户空间映射到同一接收缓存区 

2、发送进程通过系统调用（copy_from_user）将数据发送到内核缓存区。由于内 核缓存区和接收进程用户空间存在映射关系，故相当于也发送了接收进程的用户 空间，实现了跨进程通信

