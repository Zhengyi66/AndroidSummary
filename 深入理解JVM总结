
一、Java内存区域与内存溢出
1 运行时数据区域
 
1.1、程序计数器
程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
作用：
通过改变程序计数器的值来确定下一条指令执行的字节码地址。
特点：
	此区域是JVM中唯一没有规定OutOfMemoryError的区域。
	线程私有

1.2、Java虚拟机栈
描述Java方法执行的内存模型。
每个Java方法在执行时，都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
特点：
	线程私有
StackOverflowError：线程请求的栈深度大于虚拟机允许的深度，则抛出此异常
OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

栈帧(Stack Frame)：
用于支持虚拟机进行方法调用和方法执行的数据结构。
作用：
	存储方法的局部变量表、操作数栈、动态链接、方法出口等信息。
注：
	在编译代码的时候，栈帧中需要多大局部变量表内存，多深操作数栈都已经完全确定。不会受到程序运行期变量数据的影响。
 
　注意：
　　在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。
　　执行引擎运行的所有字节码指令都只针对当前栈帧进行操作

局部变量表 (Stack Frame)：
①是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
并且在编译期时就已经确定该方法所需要分配的局部变量表的最大容量。
②存放了编译期可知的各种基本数据类型(boolean、byte、char、shot、int、float、long、double)、对象引用(reference类型)和returnAddress类型(它指向了一条字节码指令地址)
作用：
	存放方法参数和局部变量
注：
	如果是成员变量或者是定义在方法外的对象引用，它们存储在堆中。因为堆中是线程共享数据

1.3、本地方法栈
区别于Java虚拟机栈的是，Java虚拟机栈为Java方法(也就是字节码)服务，而本地方法栈则未虚拟机使用到的Native方法服务。
特点：
	线程私有
StackOverflowError、OutOfMemoryError

1.4、Java堆
对于绝大多数应用来说，这块区域是JVM所管理的内存中最大的一块。线程共享，主要存放对象实例和数组。
 
	JVM内存划分为堆内存和非堆内存，堆内存分为年轻代(YoungGen)和老年代(OldGen)，非堆内存就一个永久代(PermGen) 
	年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8：1：1
	堆内存作用：存放对象。垃圾收集器收集的就是这些对象
	非堆内存作用：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。
注：
	Java8使用元空间(MetaSpace)代替永久代，它们都是方法区的实现，最大的区别是：元空间并不在JVM中，而是使用本地内存。

分代概念：
新生成的对象首先放到年轻代Eden区，当Eden区空间满了，触发Minor GC，存活下来的对象移动到Survivor0区
Survivor0区满后触发Minor GC，Survivor0区存活的对象移动到Survivor1区，这样保证了一段时间内总有一个Survivor区为空。经过多次Minor GC 仍然存活的对象移动到老年代。

老年代存储长期存活的对象，占满时会触发Major GC = Full GC，GC期间会停止所有线程等待GC完成。所以对响应要求高的应用应该尽量少发生Major GC，避免响应超时

Minor GC：清理年轻代
Major GC：清理老年代
Full GC：清理整个堆空间
所有GC都会停止应用所有线程

1.5、方法区
方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。



二、Class类文件结构
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件中，中间没有添加任何分隔符，这使得Class文件中存储的内容几乎都是程序运行的必要数据，没有空隙存在。
当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
存储格式：
	Class文件采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表
无符号数：
	无符号数属于基本数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数。
	无符号数用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。
表：
	表是由多个无符号数或者其它表作为数据项构成的复合数据类型，所有表都习惯性的以“_info”结尾。整个Class文件本质上也是一张表
注意：
	任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件中（也可以通过类加载器直接生成）

Class文件格式：
 

2.1、Magic与Class版本
Magic：
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用就是确定这个Class文件能否被虚拟机识别。固定值为0xCAFEBABE。
Class版本：
紧接着魔数的4个字节存储Class文件的版本号。
第5、6个字节是次版本号（Minor Version）
第7、8个字节是主版本号（Major Version）

2.2、常量池
紧接着主次版本号之后是常量池入口，常量池可以理解为Class文件中的资源仓库。
特点：
	它是Class文件结构中与其它项目关联最多的数据类型
	占用Class文件空间最大的数据项目之一
	Class文件中第一个出现的表类型的数据项目
constant_pool_count: 常量池容量计数值
由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置u2类型的数据，代表常量池容量计数值(constant_pool_count)。只有常量池中计数器的值从1开始，不是0

constant_pool：常量池
常量池中主要存储两大类型常量：字面量（Literal）和符号引用（Symbolic References）
字面量：
	字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。
符号引用：
	符号引用属于编译原理方面的概念，包括了下面3类常量：
	类和接口的全限定包名
	字段的名称和描述符
	方法名称和描述符

2.3、访问标志
access_flags:
在常量池结束之后，紧接着两个字节代表访问标志（access_flags），这个类用于识别一些类或者接口层次的访问信息，包括：这个Class是类还接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

2.4、类索引、父类索引与接口索引集合
this_class：类索引：确定这个类的全限定名
super_class：父类索引：确定这个类的父类的全限定名
interfaces_count：接口计数器：表示索引表容量
interfaces：接口索引集合
作用：
Class文件中通过这三项来确定这个类的集成关系


2.5、字段表集合
field_info：用于描述接口或类中声明的变量
包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性集合表（attributes）几项

3.6、方法表集合
method_info：  
方法表结构和字段表结构一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性集合表（attributes）几项。

3.7、属性表集合
attribute_info：calss文件、字段和方法拥有的属性表集合，其中code属性代表的是程序代码编译后的字节码形式指令，在code中this是默认参数

三、虚拟机类加载机制
加载—>校验—>准备—>解析—>初始化
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
3.1、加载
-> 查找并加载类的二进制数据。
加载是“类加载”（Class Loading）过程的一个阶段，虚拟机需要完成一下3件事：
1.	通过一个类的全限定名来获取定义此类的二进制字节流
2.	将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3.	在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
  加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
3.2、验证
-> 确保被加载的类的正确性
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
符号引用验证：确保解析动作能正确执行。
验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
3.3、准备
-> 为类的静态变量分配内存，并将其初始化为默认值
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配
3.4、解析
-> 把类中的符号引用转换为直接引用
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
3.5、初始化
-> 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。
在Java中对类变量进行初始值设定有两种方式：
  ①声明类变量是指定初始值
  ②使用静态代码块为类变量指定初始值
JVM初始化步骤
 1、假如这个类还没有被加载和连接，则程序先加载并连接该类
 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
 3、假如类中有初始化语句，则系统依次执行这些初始化语句
类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
– 创建类的实例，也就是new的方式
– 访问某个类或接口的静态变量，或者对该静态变量赋值
– 调用类的静态方法
– 反射（如Class.forName(“com.shengsiyuan.Test”)）
– 初始化某个类的子类，则其父类也会被初始化
– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类

四、内存分配与回收策略
Java自动内存管理机制的目的：
-	给对象分配内存
-	回收分配给对象的内存

4.1、对象优先分配在Eden区上
	大多数情况下，对象在新生代的Eden区上分配。当Eden区上没有足够的空间进行分配时，虚拟机将触发一次Minor GC。
	新生代可用的空间为90%(Eden区+1个Survivor区)。
4.2、大对象直接进入老年代
	大对象指：需要大量连续内存空间的Java对象。最典型大对象就是很长的字符串以及数组。
	经常出现大对象容易导致内存还有不少空间时就提前触发GC来获取足够的连续空间来安置它们。
4.3、长期存活的对象进入老年代
	虚拟机采用的分代收集思想管理内存，为了能够识别新生代和老年代，虚拟机给每个对象定义了一个对象年龄（Age）计数器。
如果对象在Eden区出生并经历过第一次Minor GC后仍然存活，并且能被Survivor容纳
话，将被移动到Survivor空间中，并且对象的年龄设定为1。对象在Survivor区中每熬过
一次MinorGC，年龄就增加1岁，当他的年龄增加到一定程度（默认15岁），将会被移动到
老年代中。
4.4、动态对象年龄判断
为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了
MaxTenruingThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的
总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需
等到MaxTenruingThreshold中要求的年龄。
4.5、空间分配担保
在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有
对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟
机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老
年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试
进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于或者HandlePromotionFailure
设置不允许冒险，那这时需要改为进行一次FullGC。

五、垃圾收集算法
在进行垃圾收集之前，首先要确定这个对象是否可以被回收
1、垃圾标记算法
1.1、引用计数器法
给对象添加一个引用计数器，每当有一个地方引用他时，计数器的值就会加1；当引用失效时，计数器的值就减1；当计数器的值为0时，表示这个对象不在被引用，可以被回收。
缺点：
	无法解决对象间相互引用的问题
1.2、可达性分析算法
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连时，则证明此对象是可回收的对象。
Java中可以作为GC Roots的对象包括一下几种：
-	虚拟机栈（栈帧中的本地变量表）中引用的对象
-	方法区中类静态属性应用的对象
-	方法区中常量引用的对象
-	本地方法栈中JNI（Native方法）引用的对象

2、垃圾收集算法
2.1、标记-清除算法
“标记-清除”（Mark-Sweep）算法是最基础的收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程使用垃圾标记算法。后面其它算法都是基于这种思路对其不足进行改进得到的。
缺点：
-	效率问题：标记和清除的效率不高
-	空间问题：标记清除过后会产生大量不连续的内存碎片。空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集。
 

2.2、复制算法
为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了。它将可用内存按容量划分为大小相等的2块，每次只使用其中一块。当其中一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
优点：
	实现简单、在对象存活率较低的情况下效率很高
缺点：
	每次只能使用其中一半内存
 
现在商用JVM都采用这种收集算法来回收新生代，因为新生代的对象基本上都是朝生夕死的，存活下来的对象约占10%，所以需要复制的对象比较少，效率高。

2.3、标记-整理算法
复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般都不使用复制算法。
“标记-整理”（Mark-Compact）算法：
	首先标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
  

2.4、分代收集算法
当前商业虚拟机都采用分代收集算法，根据对象存活周的不同，将内存划分为几块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点，采用适当的收集算法。
新生代中每次垃圾收集时都会伴随大量对象的死亡，只有少量对象存活，适合复制算法。
老年代对象存活效率高、没有额外空间对他进行分配担保，必须使用标记-清除或者标记整理算法来进行回收
六、类与类加载器
6.1、类与类加载器
对于任意一个类，都需要由加载它的类加载器和这个类的本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名空间。
比较两个类是否相等，只有在这两个类由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这连个类就必定不相等。
6.2、双亲委派模型
从Java虚拟机角度来说只存在两种类加载器：
-	启动类加载器，这个类加载器使用C++语言实现，是虚拟机自身的一部分
-	所有其它类加载器，由Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader
从Java开发者角度，类加载器可以划分以下3中：
-	启动类加载器（Bootstrap ClassLoader）
-	扩展类加载器（Extension ClassLoader）
-	应用程序类加载器（Application ClassLoader），ClassLoader中getSystemClassLoader()方法的返回值，所以也称为系统类加载器
 
上图中展示的类加载之间的这种层次关系，称为类加载器的双亲委派模型。
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当应有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。
双亲委派的工作过程：
如果一个类加载收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的类加载请求最终都因该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。
双亲委派的优势：
-	避免重复加载：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父类已经加载了该类时，就没有必要子ClassLoader再加载一次。
-	避免核心类被篡改：通过委托的方式，保障了核心库加载不会被替换。比如：java.lang.Object类，无论哪个类需要加载，最终都委派给模型顶端的启动类加载器进行加载，可以保障Object类在各种类加载器中都是同一个类。否则，没有双亲委派机制的话，用户自己编写了一个java.lang.Object，并放在程序的classPath中，那么系统将会出现Object类，Java类型体系中最基本的行为也无法保障，应用程序也将变得一片混乱。
6.3、破坏双亲委派模型

七、Java内存模型与线程
Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
1、Java内存模型
1.1、主内存与工作内存
Java内存模型规定了所有的变量都存储在主内存中。
每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程变量所有的操作（读取、赋值等）都必须在工作内存中进行，而不能直接读取主内存中的变量。线程间变量的传递需要通过主内存来完成

1.2、内存间交互操作

1.3、volatile型变量规则
作用：保持内存可见性和防止指令重排序
可见性：
	当一个变量被volatile修饰后，就具备了对所有线程的可见性。可见性指：当一条线程修改了这个变量的值，新值对于其它线程来说是可以立即得知的。
	普通变量的值在线程间传递需要通过主内存来完成，因此做不到可见性。
注意：
	虽然volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立即反应到其它线程中。但这并不代表基于volatile变量的运算在并发下是安全的。
volatile只能保障可见性，需要通过加锁来保障原子性。
防止指令重排：
普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。

volatile优点：
	某些情况，volatile同步机制的性能要优于锁（synchronized关键字和java.util.concurrent里面的锁），volatile读操作性能和普通变量几乎没什么差别，但写操作可能会慢一些。
在volatile与锁之间选择的依据：volatile的语义能否满足使用场景

1.4、原子性、可见性、有序性
原子性：一个程序，它要么完整的被执行，要么完全不执行。这种特性叫原子性。原子操作：独立的不可分割的操作

可见性：当一个线程修改了共享变量的值，其它线程能够立即得知这个修改

有序性：即程序执行的顺序按照代码的先后顺序执行。如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。
Java提供了volatile和synchronizated来保证线程间操作的有序性

八、Java与线程
1、Java线程调度器
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：协同式线程调度和抢占式线程调度
协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上。
	优点：实现简单，没有线程同步的问题
	缺点：线程执行时间不可控，甚至一个有编写有问题的线程，一直不告知系统进行线程切换，程序会一直阻塞在那里。
抢占式线程调度：每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。
	优点：线程执行的时间可控，不会因为线程导致系统阻塞。

Java使用的线程调度方式就是抢占式线程调度
虽然Java使用的是抢占式线程调度，但是我们可以通过设置线程的优先级来给线程分配更多的执行时间(时间片)。因为Java线程是通过映射到系统上的原生线程来实现的，所以线程调度最终还是取决于操作系统，Java线程的优先级并不一定很靠谱

2、线程状态
Java语言定义了6种线程状态，在任意时间点，一个线程有且只有其中一种状态。
-	新建(New)：创建后尚未启动状态
-	运行(Runable)：Runable包括了操作系统线程状态种的Running和Ready，即此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间
-	无限期等待(Waiting)：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其它线程显示的唤醒。以下方法会让线程进入无限期的等待状态：
	没有设置Timeout参数的Object.wait()方法
	没有设置Timeout参数的Thread.join()方法
	LockSupport.park()方法
-	定时等待(Timed Waiting)：处于这种状态的线程也不会被分配CPU执行时间，不过无需等待被其它线程显示的唤醒，在一定时间后它们会由系统自动唤醒。以下方法会让线程进入超时等待状态：
	Thread.sleep()方法
	设置了Timeout参数的Object.wait()方法
	设置了Timeout参数的Thread.join()方法
	LockSupport.parkNaons()方法
	LockSupport.parkUntil()方法
-	阻塞(Blocked)：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候方法；而“等待状态”则是在等待一段时间，或者唤醒动作的方法。在程序等待进入同步区域的时候，线程将进入这种状态。
-	结束(Terminated)：已终止线程的线程状态，线程已经结束执行。
它们的转换关系如下：
 

九、线程安全与锁优化
1、线程安全
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

1.1、Java语言中的线程安全
①：相对线程安全
相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

1.2、线程安全的实现方法
①、互斥同步
互斥同步是常见的一种并发正确性保障手段。
同步：是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程使用。
互斥：互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方法。因此互斥是因，同步是果；互斥是方法，同步是目的。
synchronized：是Java中最基本的互斥同步手段
原理：
	synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指明了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。
	根据虚拟机规范要求：在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器值减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放。

关于monitorenter和monitorexit需要注意的是：
-	首先，synchronized同步块对同一线程来说是可重入的，不会出现自己把自己锁死的问题
-	其次，synchronized同步块在已进入的线程执行完之前，会阻塞后面其他线程进入
ReentrantLock（重入锁）：java.lang.concurrent包中
在基本用法上，ReentrantLock和synchronized很相似，它们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁(lock()和unlock()方法配合try/finally语句块来完成)，另一个表现为原生语法层的互斥锁。
特点：ReentrantLock增加了一些高级功能，主要有：等待可中断、可实现公平锁、以及锁可以绑定多个条件。
-	等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
-	公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁
-	绑定多个任务：指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()可以实现一个隐含条件，如果要和多于一个的条件关联时，就不得不额外的添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。
如果需要实现上述功能，ReentrantLock是一个很好的选择。

性能比较：
在JDK1.6之后synchronized和ReentrantLock性能基本完全持平了。因此在synchronized能实现的需求下，优先使用synchronized实现同步

②、非阻塞同步
互斥同步最主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，因此这种同步也称为阻塞同步。
从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。
乐观锁：
随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗的讲，就是先进行操作，如果没有其它线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采取其它的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

在JDK1.5之后，Java程序才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的方法提供。
由于Unsafe类不是提供给用户程序调用的类，因此，如果不采用反射手段，我们只有通过Java其它API来使用它，如java.util.concurrent包里面的整数原子类，其中的一些方法使用了Unsafe类的CAS操作。
原子类有：
AtomicBoolean、AtomicInteger、AtomicIntegerArray、AtomicLong等
 

2、锁优化
高效并发是JDK1.5到JDK1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗话、轻量级锁和偏向锁等。

十、Hotspot虚拟机对象探秘
10.1、对象的创建过程
Java是一门面向对象的变成语言，在程序运行过程中无时无刻都有对象的创建。在语言层面上创建一个对象仅需要一个new关键而已，而在虚拟机中，对象（指普通对象，不包括数组和Class对象等）的创建又是怎样的过程呢？
1、类加载检查
当虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行类的加载过程

注：常量池指的是运行时常量池，类加载后，在方法区的运行时常量池中存放。存放编译期生成的各种字面量和符号引用。
2、分配内存
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
内存分配方式：指针碰撞、空闲列表
指针碰撞：如果Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间挪动一段与对象大小相等的距离，这种分配方法称为“指针碰撞”。
空闲列表：如果Java堆中的内存并不是规整的，已使用过的内存和空闲内存相互交错，那就没办法进行简单的指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表上找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。

对象的创建在虚拟机中是非常频繁的，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的。（可能出现正在给A分配内存，指针还没来得及修改，对象B又使用原来的指针来分配内存）
解决并发问题的方法：CAS、本地线程分配缓冲
CAS：对分配内存空间的动作进行同步处理—实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
本地线程分配缓冲：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲

3、初始化
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。这一操作保证对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4、设置对象头
设置初始值后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息等。这些信息存放在对象的对象头中

5、执行<init>方法
至此，new指令执行完成，对象已经创建。继续执行<init>方法，把对象按照程序员的意愿进行初始化(执行构造方法)，这样一个真正的可用的对象才算完全产生出来

10.2、对象的内存分布
在HotSpot虚拟机中，对象在内存中的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
①、对象头：
HotSpot虚拟机的对象头包括两部分信息：
-	第一部分用于存储对象自身运行时数据：
如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据在的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”
 
-	第二部分类型指针：
即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
②、实例数据：
实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要定义下来。这部分存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。
③、对齐填充
第三部分对齐填充不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整倍数，换句话说，就是对象的大小必须是8字节的整倍数。而对象头部分正好是8字节的倍数，因此，当对象的实例数据部分没有对齐时，就需要对齐填充来补全。

10.3、对象的访问定位
建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。
由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式区定位、访问堆中的对象的具体位置，所以对象方法方式也是取决于虚拟机实现而定的。
目前主流的访问方式有：句柄和直接指针两种
-	句柄：如果使用句柄访问的话，那么Java堆中将会将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。
-	直接指针：如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址
优势：
句柄的优势：最大好处是reference中存储的是稳定的句柄地址，在对象被移动时(垃圾收集时移动对象是非常普遍的行为)只会改变句柄中的实例数据指针，而reference本身不需要修改。
直接指针的优势：最大好处就是速度更快，它节省了一次指针定位的开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
HotSpot就是使用直接指针来访问对象的。
 
 



