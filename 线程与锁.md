### 一、线程安全

当多个线程访问一个共享变量时，不需要进行额外同步和协调操作，调用这个对象的方法，都能获取正确的结果，那么这个对象是线程安全的

### 二、线程安全的实现方式

#### 1、互斥同步

互斥是实现同步的一种手段。是一种阻塞式同步

Java中最基本的互斥手段是`synchronized`关键字。

##### 1.1、synchronized

synchronized经过编译后，会在同步块的前后分别形成 `monitorenter` 和 `monitorexit` 这两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。

如果synchronized没有指明锁定的对象，那就根据修饰的是实例方法还是类方法，去获取对应的对象实例或者Class对象。

**如何加锁？**

根据虚拟机规范要求：

在执行 `monitorenter` 指令时，首先会尝试获取对象的锁.如果这个对象没有被锁定或者当前线程已经拥有了这个对象的锁，把锁的计数器加1；

相应的，在执行 `monitorexit` 指令时，将锁的计数器减1，当计数器为0时，锁被释放。

如果获取对象锁失败，当前线程就要阻塞等待，直到对象锁被另一个线程释放。

**特点：**

- 对于同一个线程来说是**可重入的**，不会出现自己把自己锁死的问题

##### 1.2、ReentrantLock

api层面的可重入锁，`lock()/unlock()`配合`try/finally`使用

**高级特性：**

- 等待可中断：当持有锁的线程长时间不释放锁时，正在等待的线程可以选择放弃等待，改为处理其它事情
- 可实现公平锁：公平锁指多个线程在同一个锁时，必须按照申请锁的时间顺序依次获取锁，ReentrantLock可以通过带布尔值的构造函数实现公平锁。
- 锁可以绑定多个条件

#### 2、非阻塞式同步

基于冲突检测的乐观并发策略，就是先进行操作，如果没有其它线程争用共享数据，那操作就成功；
如果共享数据有争用，产生了冲突，那就采取其它的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止），
这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

### 三、锁的分类

#### 1、互斥同步/阻塞式/悲观锁

​	synchronized、reentrantLook

​	缺点：阻塞和唤醒线程对性能有损耗（挂起线程和恢复线程都需要转让内核态中完成，对操作系统并发性能有影响）

#### 2、非阻塞式/乐观锁

定义：基于冲突检测的乐观并发策略，就是先进行操作，如果没有其它线程争用共享数据，那操作就成功；
如果共享数据有争用，产生了冲突，那就采取其它的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止），
这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

#### 3、自旋锁与自适应自旋

为了解决互斥同步挂起线程和恢复线程带来的性能损耗。

自旋：
	如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，
	但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。
	为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。
	优点：避免了线程切换的开销
	缺点：占用处理器时间，对处理器数量有要求
	限制：自旋次数默认值是10，如果自旋超过了限度次数仍然没有成功获取锁，就使用传统方式去挂起线程了（阻塞）
自适应自旋锁：
	自适应意味着自旋时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定。
	例如：如果在同一个锁对象上，自旋刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有
	可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。如果对于某个锁，自旋很少成功获得过，那么在
	以后获取这个锁时可能省略掉自旋过程。

### 四、锁优化

#### 1、锁消除：

锁消除：是指虚拟机即时编译器在运行时，对于一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

#### 2、自旋锁与自适应自旋

解决互斥同步挂起线程和恢复线程带来的性能损耗

#### 3、锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体内的，这样即使没有线程竞争，频繁的互斥同步操作也会带来不必要的性能损耗。

这时候就可以将锁的同步范围扩展（粗化）到整个同步操作的外部，这样**只需要加一次锁**就行了。

#### 4、轻量级锁

轻量级锁并不能代替传统的重量级锁，它的本意只是在没有多线程竞争的条件下，**减少传统的重量级锁使用操作系统互斥量**产生的性能消耗。

**缺点：**

如果没有竞争，轻量级锁使用了CAS操作避免了使用互斥量的开销；但是如果存在锁竞争，除了互斥量外，还额外发生了CAS操作，因此有竞争的情况下，轻量级锁比传统比传统的重量级锁更慢。

在有多线程竞争的时候，轻量级锁会膨胀为重量级锁

#### 5、偏向锁

**目的：**消除无竞争情况下的同步原语，进一步提高运行性能。

轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的信号量；

偏向锁是在无竞争的情况下把整个同步操作都消除掉，连CAS都不需要了。

**如何实现：**

偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其它线程获取，则偏向锁的线程永远不需要同步。





